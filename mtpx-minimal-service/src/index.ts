import {
  createApp,
  setupGracefulShutdown,
  requestLogger,
  requireRole,
  z,
  type Context,
  type EventContext,
  type EventSubscriptionContext,
} from "@multpex/typescript-sdk";

const INSTANCE_ID = process.env.INSTANCE_ID || crypto.randomUUID().slice(0, 8);
const IS_PRODUCTION = process.env.NODE_ENV === "production";

const service = createApp({
  name: "minimal-service",
  instanceId: INSTANCE_ID,
  namespace: "minimal-service",  // Namespace isolado para evitar conflitos
  health: {
    enabled: true,
    healthRoute: "/minimal-service/health",
    readyRoute: "/minimal-service/ready",
    liveRoute: "/minimal-service/live",
  },

  // Logging integrado - service.logger e ctx.logger dispon√≠veis automaticamente
  logging: {
    level: IS_PRODUCTION ? "info" : "debug",
    basePath: "./logs",
    file: IS_PRODUCTION,    // Habilita log em arquivo apenas em produ√ß√£o
    console: true,          // Console sempre habilitado
    pretty: !IS_PRODUCTION, // Pretty print em desenvolvimento
  },

  // Runtime defaults (timezone, etc.)
  defaults: {
    datetime: { displayTimezone: "America/Sao_Paulo" },
  },

  // Connection examples:
  // connect: "tcp://localhost:9999?token=dev-secret",  // TCP for development/remote debugging
  // connect: "/tmp/multpex.sock",                      // Unix socket (default)
  // bulkhead: { maxConcurrent: 200 },                  // Override defaults
  // bulkhead: false,                                   // Or disable entirely
});

service.use(requestLogger());

// x-request-id is now auto-generated by SDK (from header > meta > UUID)

// Lifecycle hooks - usando service.logger integrado
service.beforeStart(async () => service.logger.info(`Initializing instance ${INSTANCE_ID}...`));
service.afterStart(async () => service.logger.info(`Service ready`, { instanceId: INSTANCE_ID }));
service.beforeStop(async () => service.logger.info(`Shutting down instance ${INSTANCE_ID}...`));

const createItemSchema = z.object({
  name: z.string().min(1).max(100),
  price: z.number().positive(),
  tags: z.array(z.string()).optional(),
});

type CreateItemInput = z.infer<typeof createItemSchema>;

const items = new Map<
  string,
  { id: string; name: string; price: number; tags?: string[] }
>([
  ["1", { id: "1", name: "Widget", price: 19.99, tags: ["popular"] }],
  ["2", { id: "2", name: "Gadget", price: 29.99 }],
]);

// Actions (CRUD)

// List (with optional filtering by query params)
service.action("list", { route: "/minimal-service/items", method: "GET" }, async (ctx: Context) => {
  let result = Array.from(items.values());

  if (ctx.query?.id) {
    result = result.filter((item) => item.id === ctx.query.id);
  }

  if (ctx.query?.name) {
    result = result.filter((item) =>
      item.name.toLowerCase().includes(ctx.query.name.toLowerCase())
    );
  }

  return { items: result, instanceId: INSTANCE_ID };
});

service.action(
  "get",
  { route: "/minimal-service/items/:id", method: "GET" },
  async (ctx: Context) => {
    const item = items.get(ctx.params.id);
    if (!item) return { error: "Not found", statusCode: 404 };
    return item;
  },
);

// Create (with validation)
service.action(
  "create",
  {
    route: "/minimal-service/items",
    method: "POST",
    validate: createItemSchema,
  },
  async (ctx: Context<CreateItemInput>) => {
    const id = crypto.randomUUID();
    const item = { id, ...ctx.body };
    items.set(id, item);

    ctx.emit("item.created", { itemId: id, name: ctx.body.name });

    return item;
  },
);

/*
// pode ser permiss√£o direta ou grupo de permiss√µes
const VOUCHER_EDITOR = {"type": "JWT", "values": ["DELETE_VOUCHER","EDIT_VOUCHER"] };
const ADMIN = {"type": "JWT", "values": "ADMIN" };

// Delete (auth required)
service.action(
  "delete",
  { route: "/items/:id", method: "DELETE", auth: true, roles: VOUCHER_EDITOR },
  async (ctx: Context) => {
    if (!items.delete(ctx.params.id)) {
      return { error: "Not found", statusCode: 404 };
    }
    ctx.emit("item.deleted", { itemId: ctx.params.id });
    return { success: true };
  }
);
*/

// Delete (auth required)
service.action(
  "delete",
  { route: "/minimal-service/items/:id", method: "DELETE", auth: true, roles: ["admin"] },
  async (ctx: Context) => {
    if (!items.delete(ctx.params.id)) {
      return { error: "Not found", statusCode: 404 };
    }
    ctx.emit("item.deleted", { itemId: ctx.params.id });
    return { success: true };
  },
);

service.on(
  "order.placed",
  async (event: EventContext<{ itemId: string }>, _ctx) => {
    console.log(`üì¶ Order placed for item: ${event.payload.itemId}`);
  },
);

// Handler with context (db, call, emit access)
service.on(
  "payment.received",
  async (
    event: EventContext<{ amount: number }>,
    ctx: EventSubscriptionContext,
  ) => {
    console.log(`üí∞ Payment: $${event.payload.amount}`);
    ctx.emit("notification.payment", { amount: event.payload.amount });
  },
);

service.on("audit.*", async (event: EventContext, _ctx) => {
  console.log(`üìù Audit: ${event.name}`);
});

service.group("/minimal-service/admin", (g) => {
  g.use(requireRole("admin"));

  g.action("stats", { route: "/stats", method: "GET" }, async () => {
    return {
      totalItems: items.size,
      totalValue: Array.from(items.values()).reduce(
        (sum, i) => sum + i.price,
        0,
      ),
    };
  });
});

service.addHealthCheck("database", async () => ({
  name: "database",
  status: "healthy",
  details: { connections: 5 },
}));

const mockMode = process.env.MOCK_MODE === "true";

if (mockMode) {
  console.log(
    "üß™ Mock mode - run with MOCK_MODE=true to skip sidecar connection\n",
  );

  const result = createItemSchema.safeParse({ name: "Test", price: 10 });
  console.log(`Validation test: ${result.success ? "‚úÖ" : "‚ùå"}\n`);

  console.log("Registered actions:", service.getActionNames().join(", "));
  console.log("Event subscriptions:", service.getEventNames().join(", "));
} else {
  await service.start();

  await service.cors({ allowAnyOrigin: true });

  // Configurar cache DEPOIS de start() (requer conex√£o ao sidecar)
  await service.cache({
    defaultPolicy: {
      enabled: true,
      defaultTtlSeconds: 60,
    },
    endpoints: [
      { action: "list", ttlSeconds: 60 },  // 5 min para listagem
      { action: "create", ttlSeconds: -1 }, // Nunca cachear mutations
      { action: "delete", ttlSeconds: -1 },
    ],
  });

  console.log(`üöÄ Service running (Node: ${service.getNodeId()})`);

  // Setup graceful shutdown (safe for hot reload - only registers once)
  setupGracefulShutdown(service);
}
